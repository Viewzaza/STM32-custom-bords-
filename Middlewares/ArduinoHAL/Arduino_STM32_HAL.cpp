#include "Arduino_STM32_HAL.h"
#include "stm32f1xx_hal.h" // Ensure this is correct for your MCU series (F1 here)

// External declaration for the SPI handle used by the application
// This handle is typically generated by STM32CubeMX in main.c or spi.c
extern SPI_HandleTypeDef hspi1;

// Definition of the global SPI object
SPIClass SPI(&hspi1); // Initialize with the address of the HAL SPI handle

// --- Core Arduino Functions ---
void delay(uint32_t ms) {
    HAL_Delay(ms);
}

// DWT (Data Watchpoint and Trace) based delayMicroseconds
// Ensure DWT is enabled:
// In main.cpp, before calling this:
// CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
// DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
// DWT->CYCCNT = 0; // Reset counter
void delayMicroseconds(uint32_t us) {
    uint32_t start_tick = DWT->CYCCNT;
    uint32_t delay_ticks = us * (HAL_RCC_GetHCLKFreq() / 1000000);
    while ((DWT->CYCCNT - start_tick) < delay_ticks);
}

void pinMode(uint16_t pin_alias, uint8_t mode) {
    // This function is more relevant for dynamic pin configuration.
    // For fixed pins like TFT control lines, they are pre-configured by MX_GPIO_Init().
    // However, one might implement it for completeness or other GPIO uses.
    // Example for a generic pin (not used by TFT fixed pins directly in this setup):
    /*
    GPIO_InitTypeDef GPIO_InitStruct = {0};
    GPIO_TypeDef* GPIO_Port;
    uint16_t GPIO_Pin_Num;

    // Simplified mapping - extend as needed
    if (pin_alias == 13) { // Example: User LED on some Nucleo boards
        GPIO_Port = GPIOB; // Change to your specific port
        GPIO_Pin_Num = GPIO_PIN_13; // Change to your specific pin
    } else {
        return; // Unknown pin
    }

    if (mode == OUTPUT) {
        GPIO_InitStruct.Pin = GPIO_Pin_Num;
        GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
        GPIO_InitStruct.Pull = GPIO_NOPULL;
        GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
        HAL_GPIO_Init(GPIO_Port, &GPIO_InitStruct);
    } else if (mode == INPUT) {
        GPIO_InitStruct.Pin = GPIO_Pin_Num;
        GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
        GPIO_InitStruct.Pull = GPIO_NOPULL; // Or GPIO_PULLUP / GPIO_PULLDOWN
        HAL_GPIO_Init(GPIO_Port, &GPIO_InitStruct);
    } else if (mode == INPUT_PULLUP) {
        GPIO_InitStruct.Pin = GPIO_Pin_Num;
        GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
        GPIO_InitStruct.Pull = GPIO_PULLUP;
        HAL_GPIO_Init(GPIO_Port, &GPIO_InitStruct);
    }
    */
   // For this project, TFT pins are initialized by MX_GPIO_Init(), so pinMode might not be strictly needed for them.
}

void digitalWrite(uint16_t pin_alias, uint8_t val) {
    GPIO_PinState state = (val == HIGH) ? GPIO_PIN_SET : GPIO_PIN_RESET;

    if (pin_alias == TFT_CS_PIN_ALIAS) {
        HAL_GPIO_WritePin(ILI9341_CS_PORT, ILI9341_CS_PIN, state);
    } else if (pin_alias == TFT_DC_PIN_ALIAS) {
        HAL_GPIO_WritePin(ILI9341_DC_PORT, ILI9341_DC_PIN, state);
    } else if (pin_alias == TFT_RST_PIN_ALIAS) {
        HAL_GPIO_WritePin(ILI9341_RST_PORT, ILI9341_RST_PIN, state);
    }
    // XPT2046 Pin Mappings
    else if (pin_alias == XPT2046_CS_PIN_ALIAS) {
        HAL_GPIO_WritePin(XPT2046_CS_PORT, XPT2046_CS_PIN, state);
    } else if (pin_alias == XPT2046_CLK_PIN_ALIAS) {
        HAL_GPIO_WritePin(XPT2046_CLK_PORT, XPT2046_CLK_PIN, state);
    } else if (pin_alias == XPT2046_DIN_PIN_ALIAS) { // MOSI
        HAL_GPIO_WritePin(XPT2046_DIN_PORT, XPT2046_DIN_PIN, state);
    }
    // Add other pin mappings here if needed
}

int digitalRead(uint16_t pin_alias) {
    if (pin_alias == XPT2046_IRQ_PIN_ALIAS) {
        return HAL_GPIO_ReadPin(XPT2046_IRQ_PORT, XPT2046_IRQ_PIN) == GPIO_PIN_SET ? HIGH : LOW;
    } else if (pin_alias == XPT2046_DO_PIN_ALIAS) { // MISO
        return HAL_GPIO_ReadPin(XPT2046_DO_PORT, XPT2046_DO_PIN) == GPIO_PIN_SET ? HIGH : LOW;
    }
    // Add other pin mappings for reading if needed
    return LOW; // Default or handle unknown pins
}


// --- SPIClass Implementation ---
SPIClass::SPIClass(SPI_HandleTypeDef* hspi) : _hspi(hspi) {
    // Default SPI settings, can be overridden by beginTransaction
    _currentSettings = SPISettings(4000000, MSBFIRST, SPI_MODE0); // Default to 4MHz, MSB, Mode0
}

void SPIClass::setHandle(SPI_HandleTypeDef* hspi) {
    _hspi = hspi;
}

void SPIClass::begin() {
    // MX_SPI1_Init() is assumed to be called in main.c/main.cpp by CubeMX.
    // If not, or if re-initialization is needed:
    // HAL_SPI_Init(_hspi);
}

void SPIClass::beginTransaction(SPISettings settings) {
    _currentSettings = settings; // Store current settings

    // Check if SPI peripheral needs re-initialization based on settings
    // This is a simplified approach. A real implementation might need to de-init and re-init SPI
    // if clock speed, data mode, or bit order changes significantly from CubeMX defaults.
    // For this project, CubeMX sets SPI1 to 4.5Mbaud, CPOL=Low, CPHA=1Edge (SPI_MODE0 equivalent for Motorola)
    // and MSB first. If these are the only settings used, no HAL_SPI_Init is needed here.

    // STM32 HAL SPI configuration for CPOL and CPHA:
    // SPI_MODE0: CPOL=0, CPHA=0 -> SPI_POLARITY_LOW, SPI_PHASE_1EDGE
    // SPI_MODE1: CPOL=0, CPHA=1 -> SPI_POLARITY_LOW, SPI_PHASE_2EDGE
    // SPI_MODE2: CPOL=1, CPHA=0 -> SPI_POLARITY_HIGH, SPI_PHASE_1EDGE
    // SPI_MODE3: CPOL=1, CPHA=1 -> SPI_POLARITY_HIGH, SPI_PHASE_2EDGE

    uint32_t hal_cpol = SPI_POLARITY_LOW;
    uint32_t hal_cpha = SPI_PHASE_1EDGE;

    switch (settings._dataMode) {
        case SPI_MODE0: // CPOL=0, CPHA=0
            hal_cpol = SPI_POLARITY_LOW;
            hal_cpha = SPI_PHASE_1EDGE;
            break;
        case SPI_MODE1: // CPOL=0, CPHA=1
            hal_cpol = SPI_POLARITY_LOW;
            hal_cpha = SPI_PHASE_2EDGE;
            break;
        case SPI_MODE2: // CPOL=1, CPHA=0
            hal_cpol = SPI_POLARITY_HIGH;
            hal_cpha = SPI_PHASE_1EDGE;
            break;
        case SPI_MODE3: // CPOL=1, CPHA=1
            hal_cpol = SPI_POLARITY_HIGH;
            hal_cpha = SPI_PHASE_2EDGE;
            break;
    }

    // Only re-initialize if mode or bit order changes from the current HAL configuration
    // Note: Changing prescaler (clock speed) might also require HAL_SPI_Init.
    // For simplicity, this example assumes the CubeMX prescaler is acceptable.
    // A more robust solution would calculate and set the prescaler here.
    if (_hspi->Init.CLKPolarity != hal_cpol || _hspi->Init.CLKPhase != hal_cpha ||
        _hspi->Init.FirstBit != (settings._bitOrder == MSBFIRST ? SPI_FIRSTBIT_MSB : SPI_FIRSTBIT_LSB)) {
        
        // Store original settings to restore if needed, or ensure they are correct
        SPI_InitTypeDef current_hspi_init = _hspi->Init;

        _hspi->Init.CLKPolarity = hal_cpol;
        _hspi->Init.CLKPhase = hal_cpha;
        _hspi->Init.FirstBit = (settings._bitOrder == MSBFIRST ? SPI_FIRSTBIT_MSB : SPI_FIRSTBIT_LSB);
        
        // Potentially adjust BaudRatePrescaler based on settings._clock
        // This is complex: need to find the closest available prescaler.
        // For now, we assume the CubeMX configured speed is used or is acceptable.
        // Example: if (settings._clock == 8000000) _hspi->Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_8;
        // This would need PCLK2 frequency to calculate correctly.

        if (HAL_SPI_Init(_hspi) != HAL_OK) {
            // Error handling if SPI re-initialization fails
            // Restore previous settings or handle error
            _hspi->Init = current_hspi_init; // Restore
            HAL_SPI_Init(_hspi); // Try to re-init with old one
        }
    }
}

void SPIClass::endTransaction(void) {
    // Can be empty if no specific state needs to be restored per transaction.
    // If SPI was reconfigured, might restore to a default state here.
}

uint8_t SPIClass::transfer(uint8_t data) {
    if (!_hspi) return 0;
    uint8_t rx_data;
    HAL_StatusTypeDef status = HAL_SPI_TransmitReceive(_hspi, &data, &rx_data, 1, HAL_MAX_DELAY);
    if (status != HAL_OK) {
        // Handle SPI error, e.g., log error, re-initialize SPI
        // For now, just return 0 or the input data
        return 0; // Or data
    }
    return rx_data;
}

void SPIClass::transfer(void *buf, size_t count) {
    if (!_hspi || !buf || count == 0) return;
    // Adafruit GFX typically uses this for sending pixel data, so Transmit is often sufficient.
    // If data needs to be received into the same buffer, use TransmitReceive.
    // For ILI9341, most block transfers are transmit-only.
    HAL_StatusTypeDef status = HAL_SPI_Transmit(_hspi, (uint8_t*)buf, count, HAL_MAX_DELAY);
    if (status != HAL_OK) {
        // Handle SPI error
    }
}

// Helper for Adafruit compatibility (sometimes they use spiwrite)
void spiwrite(uint8_t d) {
  SPI.transfer(d);
}

// For compatibility with some Adafruit libraries that might call these global functions
unsigned long millis() {
    return HAL_GetTick();
}

// Global C function for printing (if needed by GFX, though it usually takes a GFX object)
// size_t write(uint8_t c) {
//    // Implement if some part of the library tries to call a global ::write
//    // e.g., redirect to a serial port or LCD
//    return 1;
// }

// Define PROGMEM, pgm_read_byte, pgm_read_word, pgm_read_dword, pgm_read_pointer
// These are for accessing data stored in program memory (Flash) on AVR MCUs.
// On ARM Cortex-M, data in Flash is directly accessible, so these macros can be simplified.
// However, const data is usually placed in Flash by the linker.
#ifndef PROGMEM
  #define PROGMEM const
#endif
#ifndef pgm_read_byte
  #define pgm_read_byte(addr) (*(const uint8_t *)(addr))
#endif
#ifndef pgm_read_word
  #define pgm_read_word(addr) (*(const uint16_t *)(addr))
#endif
#ifndef pgm_read_dword
  #define pgm_read_dword(addr) (*(const uint32_t *)(addr))
#endif
// pgm_read_pointer might be needed if GFX fonts are complex structures
// For simple glcdfont.c, it's usually arrays of bytes.

// If Adafruit_SPITFT uses `maxSPIclock`
const uint32_t maxSPIclock = 8000000; // Example, can be higher depending on STM32 and display

#ifdef __cplusplus
extern "C" {
#endif
// The glcdfont.c file expects this symbol.
// It's an array of bytes, so pgm_read_byte will work with it.
const unsigned char font[] PROGMEM = { /* Font data will be linked from glcdfont.c */ };
#ifdef __cplusplus
}
#endif

// Required by Adafruit_SPITFT.cpp if not using a specific subclass's implementation
// This is a weak stub. If the specific display driver (ILI9341) needs it, it should implement it.
// For ILI9341, it will use its own methods for sending commands/data.
// void Adafruit_SPITFT::writecommand(uint8_t c) {
//    SPI.transfer(c); // This is not how ILI9341 does it. It uses DC pin.
// }
// void Adafruit_SPITFT::writedata(uint8_t d) {
//    SPI.transfer(d); // ditto
// }

// Some Adafruit libraries might use yield() in long loops.
void yield(void) {
  // Can be empty, or can be used for cooperative multitasking, e.g., check for events.
}

// printstr for some debug/print functions in GFX
// void printstr(const char* str) {
//   // Implement if needed, e.g. send to UART
// }

// Missing C++ new/delete if not using standard library that provides them
// Or if -fno-exceptions / -fno-rtti and minimal new/delete are needed.
// Usually, STM32CubeIDE C++ projects link against a standard library version
// that provides these. If link errors for new/delete occur, add them.
// void *operator new(size_t size) { return malloc(size); }
// void operator delete(void *ptr) { free(ptr); }
// void operator delete(void *ptr, size_t size) { free(ptr); } // C++14

// String class stub if needed by any library function signatures (rarely)
// class String { public: String(const char* c) {} };
// int freeMemory() { return 0; } // if any debug code uses this.

// Define a global for the SPI handle if any C file in the libraries needs it directly
// SPI_HandleTypeDef* _SPI = &hspi1; // Not standard Adafruit practice.

// Ensure this file is part of the compilation process for the project.
// Add Middlewares/ArduinoHAL to include paths in the compiler settings.
// Add the source files for Adafruit GFX and ILI9341 to their respective
// directories and ensure they are also compiled and linked.
// Modify their includes from <Arduino.h> to "Arduino_STM32_HAL.h" and
// <SPI.h> to "Arduino_STM32_HAL.h".

// The glcdfont.c will need to be compiled as well. Its path should be added to the build.
// It provides the actual 'font' array data.
// It might need its `#include <avr/pgmspace.h>` changed or handled by our PROGMEM definitions.
// For ARM, `#define PROGMEM` (empty) or `const` is common, and `pgm_read_byte` becomes `*(addr)`.
// The definitions provided earlier should cover this.

// Make sure the `font` symbol from `glcdfont.c` is correctly linked.
// It's usually declared as `const unsigned char font[] PROGMEM = { ... }`.
// Our `extern const unsigned char font[] PROGMEM;` in this file (or the .h) should allow it to be found.
// The actual data comes from compiling glcdfont.c.

// If `Adafruit_SPITFT` or `Adafruit_GFX` directly include `avr/pgmspace.h`,
// those includes might need to be conditionally compiled out or redirected
// to a dummy file if our `pgm_read_*` macros in `Arduino_STM32_HAL.h` are sufficient.
// Often, changing `#include <avr/pgmspace.h>` to `#include "Arduino_STM32_HAL.h"`
// (which contains the pgmspace macros) is enough.

// For `glcdfont.c`:
// Change `#include <avr/pgmspace.h>` to `#include "Arduino_STM32_HAL.h"` (if it's not already done by GFX headers)
// Ensure `font` is not declared `static` in `glcdfont.c` if we are to link against it from here.
// Typically it's not static.

// Final check on SPIClass constructor:
// SPIClass SPI; // This would be the typical global definition.
// In the .h, it's `extern SPIClass SPI;`
// In this .cpp, it's `SPIClass SPI(&hspi1);`
// This ensures the global SPI object is instantiated and configured with the correct HAL SPI handle.
// The Adafruit libraries will then use this global `SPI` object.
